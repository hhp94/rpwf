#' A wrapper around `dials::grid_<functions>` to create a sklearn suitable grid
#'
#' This function takes whatever grid functions that are available in `{dials}`,
#' converts it to a sklearn suitable format by renaming the hyper parameters as
#' well as adding fixed parameters to overwrite the default values in sklearn if
#' provided and perform some cleaning such as converting R `mtry` counts to
#' Python `col_by_sample` proportion.
#'
#' @param model a model spec object defined by `{parsnip}`.
#' @param preproc a recipe object defined by `{recipes}`.
#' @param rename_fns a function to rename the grid, generated by
#' `rpwf_grid_rename_()`
#' @param .grid_fun a `dials::grid_<functions>`, e.g., `grid_random()`,
#' `grid_latin_hypercube()`. Default `NULL` assumes that no grid search is
#' performed and default params in sklearn are used. See details for custom grids.
#' @param ... additional arguments for the `.grid_fun` functions.
#'
#' @return a `rpwf_grid` object, which is just a modified `{dials}` grid but
#' made suitable for sklearn.
#' @keywords internal
rpwf_grid_gen_ <- function(model,
                           preproc,
                           rename_fns,
                           .grid_fun = NULL,
                           update_params = NULL,
                           ...) {
  params <- rpwf_finalize_params_(model = model, preproc = preproc)
  fun <- NULL
  update_list <- NULL

  # Assign these two variables. Make sure the engine specific argument overide
  # the arguements here.
  if (!is.null(model$.model_grid_fun)) {
    fun <- model$.model_grid_fun
  } else {
    fun <- .grid_fun
  }

  if (!is.null(model$.model_update_params)) {
    update_list <- model$.model_update_params
  } else {
    update_list <- update_params
  }

  if (!is.null(model$.model_grid_fun_args)) {
    grid_args <- model$.model_grid_fun_args
  } else {
    grid_args <- list(...)
  }

  if (nrow(params$pars) == 0 | is.null(fun)) {
    message("No hyper param tuning specified")
    return(NA) # If hash of NA is changed, has to update rpwf_db_init_values_()
  }
  stopifnot(".grid_fun needs to be function" = is.function(fun))

  if (!is.null(update_list)) {
    params$pars <- do.call("update", c(list(params$pars), update_list))
  }

  if (!is.null(fun)) {
    r_grid <- do.call(
      fun,
      c(list(x = params$pars), grid_args)
    )
  }

  return(
    rpwf_transform_grid_(r_grid, rename_fns = rename_fns, n_predictors = params$n_predictors)
  )
}

#' Transform the Hyper Parameter Grid
#'
#' Some hyper parameters between R and Python are transformed differently. This
#' function is a temporary solution for transformation before a more scalable
#' solution specific to each model is needed.
#'
#' @param grid the generated R grid.
#' @inheritParams rpwf_grid_gen_
#' @param n_predictors number of predictors. Needed for converting from mtry to
#' proportion.
#' @param ... other parameters needed for transformation.
#'
#' @return a transformed and renamed grid
#' @noRd
rpwf_transform_grid_ <- function(grid, rename_fns, n_predictors, ...) {
  r_grid <- dplyr::rename_with(grid, rename_fns)

  if ("max_depth" %in% colnames(r_grid)) {
    if(max(r_grid$max_depth) > 15) {
      message("high value of 'max_depth' can cause memory error")
    }
  }

  if ("colsample_bytree" %in% colnames(r_grid)) {
    message("'colsample_bytree' is detected. Converting to proportions")
    # `colsample_bytree` is mtry converted into proportion so we need a denominator.
    #  Denominator is number is number of predictors
    r_grid$colsample_bytree <- round(r_grid$colsample_bytree / n_predictors, 3)
  }

  if ("C" %in% colnames(r_grid)) {
    message("'C' is detected. Reciprocating")
    r_grid$C <- 1 / r_grid$C
  }

  return(r_grid)
}

#' Generate Functions to Rename Hyper Params to sklearn API Suitable Names
#'
#' sklearn uses different names for the same hyper params in `{parsnips}`. This
#' function create functions to rename the names generated by
#' `dials::grid_functions` into python suitable names of the hyper parameters
#' that requires tuning. Called by [dplyr::rename_with()] in `rpwf_grid_gen_()`.
#'
#' @param json json that defines how to rename the parameters.
#'
#' @return a function that returns a string of the corresponding hyper param
#' in sklearn.
#' @noRd
#'
#' @examples
#' rename_fns <- rpwf_grid_rename_(jsonlite::toJSON(list("mtry" = "colsample_bytree")))
#' rename_fns(c("mtry", "not_added"))
rpwf_grid_rename_ <- function(json) {
  dict <- force(jsonlite::fromJSON(json))
  get_name <- function(x) {
    value <- dict[[x]]
    if (is.null(value)) {
      return(x)
    } else {
      return(value)
    }
  }
  # This function is returned to be used with rename_with()
  fns <- function(x) {
    res <- vapply(x, get_name, "character")
    names(res) <- NULL
    return(res)
  }
}

#' Internal Function to Finalize the Parameters that Requires Train Data
#'
#' This function creates the finalized parameter object in R.
#'
#' @inheritParams rpwf_grid_gen_
#'
#' @return finalized parameter object.
#' @noRd
rpwf_finalize_params_ <- function(model, preproc) {
  # some parameters (mtry) requires the data to be finalized
  stopifnot("model_spec" %in% class(model) &
    "recipe" %in% class(preproc))

  # Get just the predictors of pre-transformed data
  preds <- preproc$var_info[
    which(preproc$var_info$role == "predictor"), "variable",
    drop = TRUE
  ]

  # mtry conversion to python requires ncol() and nrow() of pre-transform data
  finalized_params <- dials::finalize(
    hardhat::extract_parameter_set_dials(model),
    dplyr::select(preproc$template, dplyr::all_of(preds))
  )

  # prevent specifying of params not belonging to the model in R. Works by
  # raising an subscript out of range error if the param not found.
  tryCatch(
    {
      labels <- sapply(finalized_params$object, \(x) {
        x[["label"]]
      })
    },
    error = function(c) {
      message("Tuning params not found")
      stop(c)
    }
  )
  return(list(pars = finalized_params, n_predictors = length(preds)))
}
