# rpwf_workflow_set() ----------------------------------------------------------
#' Customized Version of `{workflowsets}`
#'
#' Wrapper around [tidyr::crossing()] that creates all combinations of recipes
#' and models.
#'
#' @param preprocs list or vector of [recipes::recipe()].
#' @param models list or vector of model spec. Generated by adding
#' [set_py_engine()] to a model, e.g. [parsnip::boost_tree()] and
#' [parsnip::set_engine()].
#' @param costs list or vector of sklearn cost optimization metrics such as
#' "neg_log_loss" and "roc_auc". Check the [docs](https://scikit-learn.org/stable/modules/model_evaluation.html)
#' for available values.
#'
#' @return tibble that contains a combination of list of recipes, models,
#' and costs.
#' @export
#' @examples
#' d <- mtcars
#' d$id <- seq_len(nrow(d))
#' m1 <- parsnip::boost_tree() |>
#'   parsnip::set_engine("xgboost") |>
#'   parsnip::set_mode("classification") |>
#'   set_py_engine(py_module = "xgboost", py_base_learner = "XGBClassifier")
#' r1 <- d |>
#'   recipes::recipe(vs ~ .) |>
#'   # "pd.index" is the special column that used for indexing in pandas
#'   recipes::update_role(id, new_role = "pd.index")
#' wf <- rpwf_workflow_set(list(r1), list(m1), "neg_log_loss")
#' wf
rpwf_workflow_set <- function(preprocs, models, costs) {
  stopifnot(is.vector(preprocs) & is.vector(models) & is.vector(costs))
  list_class_fns <- function(list) {
    c <- unique(sapply(list, class))
    return(c)
  }

  stopifnot("preproc accept list of recipes" = "recipe" ==
    list_class_fns(preprocs))
  stopifnot("models accept list of models" = "model_spec" %in%
    list_class_fns(models) & !"recipe" %in% list_class_fns(models))
  stopifnot("costs accept list of characters" = "character" %in%
    list_class_fns(costs))

  df <- tidyr::crossing(
    preprocs = unique(preprocs), models = unique(models), costs = unique(costs)
  )

  df$costs <- as.character(costs) # results is a list, this unlist that
  return(new_rpwf_workflow_set(df))
}

# rpwf_tag_recipe() ----------------------------------------------------------
#' Add a Tag to a Recipe
#'
#' Complicated workflow sets can become difficult to track. Add a tag to keep
#' track of unique recipes.
#'
#' @param obj [recipes::recipe()] object.
#' @param tag Short string description of recipe.
#'
#' @return A tagged [recipes::recipe()] object. Accessible with `obj$recipe_tag`.
#' @export
#'
#' @examples
#' r <- recipes::recipe(~., data = mtcars)
#' r <- rpwf_tag_recipe(r, "test recipe")
#' r$recipe_tag
rpwf_tag_recipe <- function(obj, tag) {
  obj$recipe_tag <- tag
  return(obj)
}

#' @rdname rpwf_augment
#' @export
rpwf_augment.rpwf_workflow_set <- function(obj, db_con, .grid_fun = NULL,
                                           ..., range = c(1L, 5000L), seed = 1234L) {
  py_module <- py_base_learner <- engine <- rename_fns <- model_mode <- NULL
  set.seed(seed)
  obj |>
    rpwf_add_model_param_(db_con) |>
    rpwf_add_desc_() |>
    rpwf_add_py_model_(db_con) |>
    rpwf_add_random_state_(range, seed = seed) |>
    rpwf_add_grid_(.grid_fun, seed = seed, ...) |>
    rpwf_Rgrid_R6_(db_con) |>
    rpwf_TrainDf_R6_(db_con, seed = seed) |>
    dplyr::select(-c(py_module, py_base_learner, engine, rename_fns, model_mode))
}

# rpwf_write_<obj>() ----------------------------------------------------------
#' Write the Hyper Param Grid Parquet File
#'
#' @param obj obj generated by [rpwf_augment()].
#'
#' @details
#' For each grid, initialize a new [RGrid], call `self$export()`, then return
#' the object. This make sure the same object called twice will just fetch
#' the result from the previous call. Hence, can't be run in parallel.
#'
#' At this point, we made sure that 1) the db is updated, 2) file is exported,
#' 3) file exists. Use the hashes for getting the grid id.
#'
#' @return Parquet files.
#' @export
rpwf_write_grid <- function(obj) {
  stopifnot("Run rpwf_augment() first!" = "Rgrid" %in% names(obj))
  for (g in obj$Rgrid) {
    g$set_attrs()$export()$set_attrs() # Export and update information in the db
  }
}

#' Write the Train/Test Data
#'
#' @param obj obj generated by [rpwf_augment()].
#'
#' @details
#' For each recipe, initialize a new [TrainDf], call `self$export()`, then return
#' the object. This make sure the same object called twice will just fetch the
#' result from the previous call.
#'
#' @return Parquet files.
#' @export
rpwf_write_df <- function(obj) {
  stopifnot("Run rpwf_augment() first!" = "TrainDf" %in% names(obj))
  for (r in obj$TrainDf) {
    r$set_attrs()$export()$set_attrs()
  }
}

#' @rdname rpwf_export_db
#' @export
rpwf_export_db.rpwf_workflow_set <- function(obj, db_con) {
  rpwf_export_wfs_(obj, db_con)
}
