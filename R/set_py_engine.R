#' Add Information about the Python Module
#'
#' Augment the model spec object generated by `{parsnip}` with information
#' needed to run sklearn models. Importantly, also passes sklearn base learner
#' specific arguments through the `args` parameter.
#'
#' @param obj a model spec object generated by [parsnip::set_engine()] and
#' [parsnip::set_mode()].
#' @param py_module a character value that select the python module that the
#' base learner comes from (i.e., `xgboost`, `sklearn.ensemble`, etc.).
#' @param py_base_learner a character value that select the python base learner,
#' (i.e., XGBClassifier, DecisionTreeClassifier, etc.).
#' @param ... not used. Include to force `con` and `args` to be specified by names
#' @param con created by [DbCon].
#' If provided will perform check if the py_base_learner is in the database or not.
#' @param args arguments passed to the python base learner via named list.
#' Boolean must be in R format, i.e., `TRUE`, `FALSE`.
#'
#' @return a model spec object with additional attributes `self$py_base_learner`
#' and `self$py_base_learner_args`.
#' @export
#'
#' @examples
#' db_con <- DbCon$new("db.SQLite", tempdir())
#' parsnip::boost_tree() |>
#'   parsnip::set_engine("xgboost") |>
#'   parsnip::set_mode("classification") |>
#'   set_py_engine(
#'     "xgboost", "XGBClassifier", db_con$con,
#'     list(
#'       eval_metric = "logloss", use_label_encoder = FALSE,
#'       verbosity = 0, silent = TRUE, n_estimators = 100
#'     )
#'   )
set_py_engine <- function(obj, py_module, py_base_learner, ...,
                          con = NULL, args = NULL) {
  stopifnot(
    "`py_module` and `py_base_learner` need to be of type character" =
      all(sapply(c(py_module, py_base_learner), is.character))
  )
  if (!is.null(con)) {
    message("Connection provided, checking if the python module is in the db")
    rpwf_chk_model_avail(con, py_module, py_base_learner, obj$engine)
  }
  # Augment the model spec object with these attributes
  obj$py_module <- py_module
  obj$py_base_learner <- py_base_learner

  if (!is.null(args)) {
    stopifnot(
      "Use named list for py learner args" =
        all("list" %in% class(args)) & !is.null(names(args))
    )
    obj$py_base_learner_args <- jsonlite::toJSON(args, auto_unbox = TRUE)
  }
  return(obj)
}

#' Internal Function to check if the Specified Model is Available in the Database
#'
#' @inheritParams rpwf_dm_obj
#' @param py_module string of what the py module is e.g., `xgboost`,
#' `sklearn.ensemble`.
#' @param py_base_learner string of what the base learner is e.g.,
#' `XGBClassifier`.
#' @param r_engine string of the r_engine used.
#'
#' @return either an error or "Model found in db".
#' @keywords internal
#' @export
#'
#' @examples
#' db_con <- DbCon$new("db.SQLite", tempdir())
#' rpwf_db_init(db_con$con, rpwf_schema()) # Create the database
#' rpwf_chk_model_avail(db_con$con, "xgboost", "XGBClassifier", "xgboost")
rpwf_chk_model_avail <- function(con, py_module, py_base_learner, r_engine) {
  stopifnot("only accept vector of length 1 as arguments" = all(
    c(length(py_module), length(py_base_learner), length(r_engine)) == 1
  ))
  query_results <- DBI::dbGetQuery(
    con,
    glue::glue_sql(
      "SELECT * FROM model_type_tbl
      WHERE py_module = ? AND py_base_learner = ? AND r_engine = ?;",
      .con = con
    ),
    list(py_module, py_base_learner, r_engine)
  )
  if (nrow(query_results) != 1) {
    print(DBI::dbGetQuery(con, "SELECT * FROM model_type_tbl;"))
    cat("\n")
    stop("Invalid scikit-learn model, select only one model from the above")
  }
  message("Valid scikit-learn model")
}

#' Copy sklearn Codes into the Project Root Folder
#'
#' These python codes are needed to work with the database. After copying the
#' codes with `rpwf_cp_py_codes()`, navigate to the "rpwf" folder and run
#' `python -m pip install -e .` to install the codes as a local python package.
#' Remove the python codes with `pip uninstall local-rpwf`
#'
#' @param proj_root_path root path of the project, generate with [DbCon] and
#' assess with DbCon$new()$proj_root_path.
#'
#' @return a newly copied folder called "rpwf" under the provided project path.
#' @export
#'
#' @examples
#' tmp <- tempdir()
#' rpwf_cp_py_codes(tmp)
#' list.files(paste0(tmp, "/rpwf"), recursive = TRUE)
rpwf_cp_py_codes <- function(proj_root_path) {
  to_folder <- paste(proj_root_path, "rpwf", sep = "/")
  if (!dir.exists(to_folder)) {
    message("creating folder 'rpwf' under provided root path")
  } else {
    message("folder 'rpwf' found, overwriting python codes in this folder")
  }
  from_folder <- system.file("python", "rpwf", package = "rpwf", mustWork = TRUE)
  file.copy(from_folder, proj_root_path, recursive = TRUE)
  message("here are the files in the 'rpwf' folder")
  print(list.files())
}
