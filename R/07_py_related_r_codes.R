#' Define the Python Learner
#'
#' Augment the model spec object generated by `{parsnip}` with information
#' needed to run `sklearn` models. Importantly, also passes `sklearn` base learner
#' specific arguments through the `...` parameter.
#'
#' @param obj a model spec object generated by [parsnip::set_engine()] and
#' [parsnip::set_mode()].
#' @param py_module a character value that select the python module that the
#' base learner comes from (i.e., `xgboost`, `sklearn.ensemble`, etc.).
#' @param py_base_learner a character value that select the python base learner,
#' (i.e., XGBClassifier, DecisionTreeClassifier, etc.).
#' @param rpwf_model_tag a string to name this model. Useful in keeping track of different
#' combinations of models.
#' @param ... arguments passed to the python base learner via named list.
#' Boolean must be in R format, i.e., `TRUE`, `FALSE`.
#'
#' @return a model spec object with additional attributes `self$rpwf_model_tag`,
#' `self$py_base_learner` and `self$py_base_learner_args`.
#'
#' @export
#'
#' @examples
#' m <- parsnip::boost_tree() |>
#'   parsnip::set_engine("xgboost") |>
#'   parsnip::set_mode("classification") |>
#'   set_py_engine(
#'     "xgboost",
#'     "XGBClassifier",
#'     "my_xgboost_model",
#'     eval_metric = "logloss",
#'     use_label_encoder = FALSE,
#'     verbosity = 0,
#'     silent = TRUE,
#'     n_estimators = 100 # Fix the `n_estimators` at 100
#'   )
set_py_engine <- function(obj, py_module, py_base_learner, rpwf_model_tag = NULL, ...) {
  stopifnot(
    "`py_module` and `py_base_learner` need to be of type character" =
      all(sapply(c(py_module, py_base_learner), is.character))
  )
  # Augment the model spec object with these attributes
  obj$py_module <- py_module
  obj$py_base_learner <- py_base_learner

  args <- list(...)
  if (length(args) > 0) {
    n <- names(args)
    stopifnot(
      "Use named list" = all(!anyNA(n) & !is.null(n))
    )
    stopifnot(
      "All args must be named" = all(length(n) == length(args) & !any(grepl("^$", n)))
    )
    stopifnot(
      "Args names have to be unique" = (length(n) == dplyr::n_distinct(n))
    )
    obj$py_base_learner_args <- jsonlite::toJSON(args, auto_unbox = TRUE)
  }

  if (!is.null(rpwf_model_tag)) {
    stopifnot(
      "rpwf_model_tag must be a character string of length 1" =
        length(rpwf_model_tag) == 1L & is.character(rpwf_model_tag)
    )
    obj$model_tag <- rpwf_model_tag
  }

  return(obj)
}

#' Copy sklearn Codes to Path
#'
#' These python codes are needed to work with the database. After copying the
#' codes with `rpwf_cp_py_codes()`, navigate to the "rpwf" folder and run
#' `python -m pip install -e .` to install the codes as a local python package.
#' Remove the python codes with `pip uninstall local-rpwf`.
#'
#' @param board a `{pins}` board object.
#' @param overwrite overwriting the copied python codes or not. Default to `FALSE`.
#'
#' @return a newly copied folder called "rpwf" under the provided project path.
#' @export
#'
#' @examples
#' tmp_dir <- tempdir()
#' rpwf_cp_py_codes(tmp_dir)
#' list.files(paste0(tmp_dir, "/rpwf"), recursive = TRUE)
rpwf_cp_py_codes <- function(board, overwrite = FALSE) {
  to_folder <- paste(board, "rpwf", sep = "/")
  copy_fns <- function() {
    from_folder <-
      system.file("python", "rpwf", package = "rpwf", mustWork = TRUE)
    file.copy(from_folder, board, overwrite = overwrite, recursive = TRUE)
  }

  if (!dir.exists(to_folder)) {
    message("creating folder 'rpwf' under provided root path")
    copy_fns()
  } else if (overwrite == TRUE) {
    message("folder 'rpwf' found, overwriting python codes in this folder")
    copy_fns()
  } else {
    message("folder 'rpwf' found, not copying codes over")
  }
}
