#' Define the Python Learner
#'
#' Augment the model spec object generated by `{parsnip}` with information
#' needed to run `sklearn` models. Importantly, also passes `sklearn` base learner
#' specific arguments through the `args` parameter.
#'
#' @param obj a model spec object generated by [parsnip::set_engine()] and
#' [parsnip::set_mode()].
#' @param py_module a character value that select the python module that the
#' base learner comes from (i.e., `xgboost`, `sklearn.ensemble`, etc.).
#' @param py_base_learner a character value that select the python base learner,
#' (i.e., XGBClassifier, DecisionTreeClassifier, etc.).
#' @param tag a string to name this model. Useful in keeping track of different
#' combinations of models.
#' @param ... not used. Included to force `con`, `args` to be specified by names.
#' @param args arguments passed to the python base learner via named list.
#' Boolean must be in R format, i.e., `TRUE`, `FALSE`.
#'
#' @return a model spec object with additional attributes `self$tag`,
#' `self$py_base_learner` and `self$py_base_learner_args`.
#'
#' @export
#'
#' @examples
#' tmp_dir <- withr::local_tempdir()
#' db_con <- rpwf_connect_db("db.SQLite", tmp_dir)
#' parsnip::boost_tree() |>
#'   parsnip::set_engine("xgboost") |>
#'   parsnip::set_mode("classification") |>
#'   set_py_engine(
#'     "xgboost",
#'     "XGBClassifier",
#'     "my_xgboost_model",
#'     db_con = db_con,
#'     args = list(
#'       eval_metric = "logloss",
#'       use_label_encoder = FALSE,
#'       verbosity = 0,
#'       silent = TRUE,
#'       n_estimators = 100
#'     )
#'   )
set_py_engine <- function(obj, py_module, py_base_learner, tag = NULL, ...,
                          args = NULL) {
  stopifnot(
    "`py_module` and `py_base_learner` need to be of type character" =
      all(sapply(c(py_module, py_base_learner), is.character))
  )
  # Augment the model spec object with these attributes
  obj$py_module <- py_module
  obj$py_base_learner <- py_base_learner

  if (!is.null(args)) {
    stopifnot(
      "Use named list for py learner args" =
        all("list" %in% class(args)) & !is.null(names(args))
    )
    obj$py_base_learner_args <- jsonlite::toJSON(args, auto_unbox = TRUE)
  }

  if (!is.null(tag)) {
    stopifnot(
      "tag must be a character string of length 1" =
        length(tag) == 1L & is.character(tag)
    )
    obj$model_tag <- tag
  }

  return(obj)
}

#' Copy sklearn Codes into the Project Root Folder
#'
#' These python codes are needed to work with the database. After copying the
#' codes with `rpwf_cp_py_codes()`, navigate to the "rpwf" folder and run
#' `python -m pip install -e .` to install the codes as a local python package.
#' Remove the python codes with `pip uninstall local-rpwf`.
#'
#' @param proj_root_path root path of the project.
#' @param overwrite overwriting the copied python codes or not. Default to `FALSE`.
#'
#' @return a newly copied folder called "rpwf" under the provided project path.
#' @export
#'
#' @examples
#' tmp_dir <- withr::local_tempdir()
#' rpwf_cp_py_codes(tmp_dir)
#' list.files(paste0(tmp_dir, "/rpwf"), recursive = TRUE)
rpwf_cp_py_codes <- function(proj_root_path, overwrite = FALSE) {
  to_folder <- paste(proj_root_path, "rpwf", sep = "/")
  copy_fns <- function() {
    from_folder <-
      system.file("python", "rpwf", package = "rpwf", mustWork = TRUE)
    file.copy(from_folder, proj_root_path, recursive = TRUE)
  }

  if (!dir.exists(to_folder)) {
    message("creating folder 'rpwf' under provided root path")
    copy_fns()
  } else if (overwrite == TRUE) {
    message("folder 'rpwf' found, overwriting python codes in this folder")
    copy_fns()
  } else {
    message("folder 'rpwf' found, not copying codes over")
  }
}
