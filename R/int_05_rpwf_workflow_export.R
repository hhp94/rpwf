#' Helper Function for Running Query to Add Ids to the `workflow_set`
#'
#' This function is a wrapper for [DBI::dbGetQuery()] that also perform some
#' cleaning. Should only return one column and <= 1 row for every query.
#'
#' @param query SQL query.
#' @inheritParams rpwf_add_py_model
#' @param ... value vectors to search the tables by. Accept up to 3 values.
#'
#' @return a vector of query values.
#' @noRd
rpwf_query_ <- function(query, con, ...) {
  val_vecs <- list(...)
  query_res_list <- purrr::pmap(
    .l = val_vecs,
    \(val1, val2 = NULL, val3 = NULL) {
      val <- as.list(c(val1, val2, val3))
      DBI::dbGetQuery(con, glue::glue_sql(query, .con = con), val)
    }
  )

  stopifnot(
    "Query should only return 1 column and <= 1 row" =
      all(sapply(query_res_list, \(query) {
        ncol(query) == 1L & nrow(query) <= 1L
      }))
  )
  # Number of rows for each query
  empty_res <- sapply(query_res_list, \(query) {
    nrow(query)
  })
  # If any query finds nothing (nrow(query) == 0) then replace with NA
  query_res_list[which(empty_res == 0L)] <- NA
  return(as.vector(unlist(query_res_list))) # return an unlisted vector for mutate
}

#' Add Model Related Columns to the `workflow_set`
#'
#' @param obj a [rpwf_workflow_set()] object.
#' @inheritParams rpwf_add_py_model
#'
#' @return tibble that contains 3 additional columns "py_base_learner",
#' "py_base_learner_args", "model_mode".
#' @noRd
rpwf_add_model_param_ <- function(obj, db_con) {
  stopifnot(
    "Run rpwf_workflow_set() first!" =
      all(c("preprocs", "models", "costs") %in% names(obj))
  )
  rpwf <- obj
  # Add the py module column
  rpwf$py_module <- sapply(rpwf$models, \(x) {
    x$py_module
  })
  # Add the py_base_learner column
  rpwf$py_base_learner <- sapply(rpwf$models, \(x) {
    x$py_base_learner
  })
  # Add the r engine column
  rpwf$engine <- sapply(rpwf$models, \(x) {
    x$engine
  })
  # Check for invalid models
  purrr::pwalk(
    .l = list(
      x = rpwf$py_module, y = rpwf$py_base_learner, z = rpwf$engine
    ),
    .f = \(x, y, z) {
      rpwf_chk_model_avail_(db_con, x, y, z)
    }
  )
  # Query the rename dictionary json
  hyper_par_rename <- rpwf_query_(
    query = "SELECT hyper_par_rename FROM model_type_tbl WHERE
    py_module = ? AND py_base_learner = ? AND r_engine = ?; ",
    con = db_con$con,
    val1 = rpwf$py_module,
    val2 = rpwf$py_base_learner,
    val3 = rpwf$engine
  )
  # Add the rename fns by passing the dictionary to rpwf_grid_rename_()
  rpwf$rename_fns <- lapply(hyper_par_rename, rpwf_grid_rename_)
  # Add the base learner related args if presented
  rpwf$py_base_learner_args <- vapply(rpwf$models, \(x) {
    if (!is.null(x$py_base_learner_args)) {
      return(x$py_base_learner_args)
    } else {
      return(NA_character_)
    }
  }, "character")
  # get the model mode (regression/classification)
  rpwf$model_mode <- sapply(rpwf$models, \(x) {
    x$mode
  })
  return(rpwf)
}

#' Adds a Short Description of Each Workflow to the `workflow_set`
#'
#' @param obj object generated by `rpwf_add_model_param_()`.
#' @return tibble that contains the additional column `"model_tag"` and
#' `"recipe_tag"`.
#' @noRd
rpwf_add_desc_ <- function(obj) {
  stopifnot("Run rpwf_add_model_param_ first!" = "py_base_learner" %in% names(obj))
  # Add the model tag column
  obj$model_tag <- vapply(obj$models, \(x) {
    if (is.null(x$model_tag)) {
      return(x$py_base_learner)
    } else {
      return(x$model_tag)
    }
  }, "character")

  # Add the recipe tag column
  obj$recipe_tag <- vapply(obj$preprocs, \(x) {
    if (is.null(x$recipe_tag)) {
      return(NA_character_)
    } else {
      return(x$recipe_tag)
    }
  }, "character")

  return(obj)
}

#' Query the `model_type_id` for the Requested Model
#'
#' @param obj an object generated by `rpwf_add_model_param_()`.
#' @inheritParams rpwf_add_py_model
#'
#' @return tibble with the "model_type_id" column added.
#' @noRd
rpwf_add_py_model_ <- function(obj, db_con) {
  stopifnot(
    "add set_py_engine() to your {parsnip} model_spec object" =
      all(c("py_module", "py_base_learner") %in% names(obj))
  )

  query_res <- rpwf_query_(
    query =
      "SELECT model_type_id FROM model_type_tbl
      WHERE py_module = ? AND py_base_learner = ?",
    con = db_con$con,
    val1 = obj$py_module,
    val2 = obj$py_base_learner
  )
  # Add `model_type_id` to the accumulating object
  obj$model_type_id <- query_res
  return(obj)
}

#' Add the Random State Seeds for Python `random_state`
#'
#' @param obj an object generated by `rpwf_add_model_param_()`.
#' @param range range of seed to sample from.
#' @param seed random seed to sample the `random_state`.
#'
#' @return tibble with `"random_state"` column added.
#' @keywords internal
rpwf_add_random_state_ <- function(obj, range, seed) {
  set.seed(seed)
  stopifnot("range of random_state should be of length 2" = length(range) == 2L)
  sorted_range <- as.integer(sort(range))
  stopifnot("range should be an int vector" = !anyNA(sorted_range))
  random_state <- sample(sorted_range[1]:sorted_range[2], size = nrow(obj))
  # Add `random_state` to the accumulating object
  obj$random_state <- random_state
  return(obj)
}

#' Add Relevant Parameters to the `dials::grid_<functions>`
#'
#' @param obj object generated by `rpwf_add_model_param_()`.
#' @param seed random seed.
#' @inheritParams rpwf_grid_gen_
#'
#' @return tibble with the additional column `"grids"`.
#' @noRd
rpwf_add_grid_ <- function(obj, .grid_fun = NULL, seed, ...) {
  # These are columns from rpwf_workflow_set()
  stopifnot(
    "Run rpwf_workflow_set() first!" =
      all(c("preprocs", "models", "costs") %in% names(obj))
  )
  obj$grids <- purrr::pmap(
    .l = list(obj$models, obj$preprocs, obj$rename_fns),
    .f = \(x, y, z) {
      set.seed(seed)
      rpwf_grid_gen_(
        model = x,
        preproc = y,
        rename_fns = z,
        .grid_fun = .grid_fun,
        ...
      )
    }
  )
  return(obj)
}

#' Add Rgrid R6 Object
#'
#' This function does the heavy lifting of generating the path,
#' write the parquet, updating the database, for the provided R grids. Since the
#' function is reading from the database and only generate data as needed,
#' running this function in parallel is not recommended.
#'
#' @inheritParams rpwf_export_db
#'
#' @return A tibble with Rgrid objects added.
#' @noRd
rpwf_Rgrid_R6_ <- function(obj, db_con) {
  obj$Rgrid <- lapply(obj$grids, \(x) {
    RGrid$new(x, db_con)
  })
  return(obj)
}

#' Add TrainDf R6 Object
#'
#' Similar to [rpwf_write_grid()], this function does the heavy lifting of
#' generating the path, write the parquet, and updating the database for the
#' recipe of the transformed data. Since the function is reading from the
#' database and only generating data as needed, running this function in parallel
#' is not recommended.
#'
#' @inheritParams rpwf_export_db
#'
#' @return A tibble with Rgrid objects added.
#' @noRd
rpwf_TrainDf_R6_ <- function(obj, db_con) {
  obj$TrainDf <- lapply(obj$preprocs, \(x) {
    TrainDf$new(x, db_con)
  })
  return(obj)
}

#' Recheck if file exists
#'
#' @param R6_obj TrainDf or RGrid
#' @inheritParams rpwf_add_py_model
#'
#' @return Vector of TRUE/FALSE for files exists or not.
#'
#' @noRd
pin_exists_recheck_ <- function(R6_obj, db_con) {
  sapply(R6_obj, \(x) { pins::pin_exists(x$board, x$pin_name) })
}

#' Add Grid Id to workflow/data set
#'
#' @inheritParams rpwf_export_db
#'
#' @return A tibble with grid_id added.
#' @noRd
rpwf_Rgrid_R6_id_ <- function(obj, db_con) {
  grid_obj_id <- rpwf_query_(
    query = "SELECT grid_id FROM r_grid_tbl WHERE grid_hash = ?",
    con = db_con$con,
    val1 = sapply(obj$Rgrid, \(x) {
      x$hash
    })
  )
  stopifnot("grid id not found, `rpwf_write_grid()` first?" = !anyNA(grid_obj_id))
  stopifnot("grid parquet not found, `rpwf_write_grid()` first?" = all(
    pin_exists_recheck_(obj$Rgrid[which(grid_obj_id != 1)], db_con) # Don't check grid if id = 1
  ))
  obj$grid_id <- grid_obj_id
  return(obj)
}

#' Add Df Id to workflow/data set
#'
#' @inheritParams rpwf_export_db
#'
#' @return A tibble with df_id added.
#' @noRd
rpwf_TrainDf_R6_id_ <- function(obj, db_con) {
  df_obj_id <- rpwf_query_(
    con = db_con$con,
    query = "SELECT df_id FROM df_tbl WHERE df_hash = ?",
    val1 = sapply(obj$TrainDf, \(x) {
      x$hash
    })
  )
  stopifnot("df id not found, `rpwf_write_df()` first?" = !anyNA(df_obj_id))
  stopifnot("df parquet not found, `rpwf_write_df()` first?" = all(pin_exists_recheck_(obj$TrainDf, db_con)))
  obj$df_id <- df_obj_id
  return(obj)
}

#' Hash the Rows of the Workflow to Check if its Already in the Db
#'
#' Export the object that has been processed by the other functions into the
#' database so that python can query the information.
#'
#' @param df object created by `rpwf_augment()`.
#'
#' @return a vector of [rlang::hash].
#' @noRd
rpwf_wflow_hash_ <- function(df) {
  apply(as.data.frame(df), 1, rlang::hash)
}

#' Generate the Export to DB functions
#'
#' @param required_col String of required columns.
#'
#' @return a function that add the required columns to the database.
#' @noRd
rpwf_export_fns_ <- function(required_cols) {
  fns <- function(obj, db_con) {
    # These columns must be present
    required <- force(required_cols)

    # Query the wflow that's already in the database
    db_wflow_hash <- rpwf_wflow_hash_(
      dplyr::select(
        DBI::dbGetQuery(db_con$con, glue::glue("SELECT * FROM wflow_tbl;")),
        dplyr::all_of(required)
      )
    )

    # Generate hash of current wflows
    to_export_hash <- rpwf_wflow_hash_(dplyr::select(obj, dplyr::all_of(required)))
    matched_wflow <- to_export_hash %in% db_wflow_hash

    if (any(matched_wflow)) {
      message("the following workflows are already in the database\n")
      print(obj[matched_wflow, which(names(obj) %in% required)])
    }
    # Only add the workflow that's not in the database
    to_export <- as.data.frame(obj[!matched_wflow, which(names(obj) %in% required)])

    if (nrow(to_export) == 0) {
      message("All workflows found in db, exiting...")
      return(0)
    } else {
      message("Exporting workflows to db...")
      DBI::dbAppendTable(db_con$con, name = "wflow_tbl", value = to_export)
    }
  }
  return(fns)
}

#' Function for Exporting `rpwf_workflow_set()`
#'
#' @inheritParams rpwf_export_db
#'
#' @noRd
rpwf_export_wfs_ <- function(obj, db_con) {
  rpwf_Rgrid_R6_id_(obj = obj, db_con = db_con) |>
    rpwf_TrainDf_R6_id_(db_con = db_con) |>
    rpwf_export_fns_(
      c(
        "df_id",
        "grid_id",
        "model_tag",
        "recipe_tag",
        "costs",
        "model_type_id",
        "random_state",
        "py_base_learner_args"
      )
    )(db_con = db_con)
}
