#' Define the Python Learner
#'
#' Augment the model spec object generated by `{parsnip}` with information
#' needed to run `sklearn` models. Importantly, also passes `sklearn` base learner
#' specific arguments through the `args` parameter.
#'
#' @param obj a model spec object generated by [parsnip::set_engine()] and
#' [parsnip::set_mode()].
#' @param py_module a character value that select the python module that the
#' base learner comes from (i.e., `xgboost`, `sklearn.ensemble`, etc.).
#' @param py_base_learner a character value that select the python base learner,
#' (i.e., XGBClassifier, DecisionTreeClassifier, etc.).
#' @param tag a string to name this model. Useful in keeping track of different
#' combinations of models.
#' @param ... not used. Included to force `con`, `args` to be specified by names.
#' @param con created by [DbCon].
#' If provided will perform check to see if the specified py_base_learner is in
#' the database or not.
#' @param args arguments passed to the python base learner via named list.
#' Boolean must be in R format, i.e., `TRUE`, `FALSE`.
#'
#' @return a model spec object with additional attributes `self$tag`,
#' `self$py_base_learner` and `self$py_base_learner_args`.
#'
#' @export
#'
#' @examples
#' tmp_dir <- withr::local_tempdir()
#' db_con <- rpwf_connect_db("db.SQLite", tmp_dir)
#' parsnip::boost_tree() |>
#'   parsnip::set_engine("xgboost") |>
#'   parsnip::set_mode("classification") |>
#'   set_py_engine(
#'     "xgboost",
#'     "XGBClassifier",
#'     "my_xgboost_model",
#'     con = db_con$con,
#'     args = list(
#'       eval_metric = "logloss",
#'       use_label_encoder = FALSE,
#'       verbosity = 0,
#'       silent = TRUE,
#'       n_estimators = 100
#'     )
#'   )
set_py_engine <- function(obj, py_module, py_base_learner, tag = NULL, ...,
                          con = NULL, args = NULL) {
  stopifnot(
    "`py_module` and `py_base_learner` need to be of type character" =
      all(sapply(c(py_module, py_base_learner), is.character))
  )
  if (!is.null(con)) {
    message("Connection provided, checking if the python module is in the db")
    rpwf_chk_model_avail_(con, py_module, py_base_learner, obj$engine)
  }
  # Augment the model spec object with these attributes
  obj$py_module <- py_module
  obj$py_base_learner <- py_base_learner

  if (!is.null(args)) {
    stopifnot(
      "Use named list for py learner args" =
        all("list" %in% class(args)) & !is.null(names(args))
    )
    obj$py_base_learner_args <- jsonlite::toJSON(args, auto_unbox = TRUE)
  }

  if (!is.null(tag)) {
    stopifnot(
      "tag must be a character string of length 1" =
        length(tag) == 1L & is.character(tag)
    )
    obj$model_tag <- tag
  }

  return(obj)
}

#' Internal Function to check if the Specified Model is Available in the Database
#'
#' @inheritParams rpwf_dm
#' @param py_module string of what the py module is e.g., `xgboost`,
#' `sklearn.ensemble`.
#' @param py_base_learner string of what the base learner is e.g.,
#' `XGBClassifier`.
#' @param r_engine string of the r_engine used.
#'
#' @return either an error or "Model found in db".
#' @keywords internal
#' @export
#'
#' @examples
#' tmp_dir <- withr::local_tempdir()
#' db_con <- rpwf_connect_db("db.SQLite", tmp_dir)
#' rpwf_db_init_(db_con$con, rpwf_schema()) # Create the database
#' rpwf_chk_model_avail_(db_con$con, "xgboost", "XGBClassifier", "xgboost")
rpwf_chk_model_avail_ <- function(con, py_module, py_base_learner, r_engine) {
  stopifnot("only accept vector of length 1 as arguments" = all(
    c(length(py_module), length(py_base_learner), length(r_engine)) == 1
  ))
  query_results <- DBI::dbGetQuery(
    con,
    glue::glue_sql(
      "SELECT * FROM model_type_tbl
      WHERE py_module = ? AND py_base_learner = ? AND r_engine = ?;",
      .con = con
    ),
    list(py_module, py_base_learner, r_engine)
  )
  if (nrow(query_results) != 1) {
    stop(
      paste(
        "Invalid scikit-learn model, select only one model",
        "from `rpwf_avail_models()` or add models with `rpwf_add_py_model()`"
      ),
      sep = " "
    )
  }
}

#' Copy sklearn Codes into the Project Root Folder
#'
#' These python codes are needed to work with the database. After copying the
#' codes with `rpwf_cp_py_codes()`, navigate to the "rpwf" folder and run
#' `python -m pip install -e .` to install the codes as a local python package.
#' Remove the python codes with `pip uninstall local-rpwf`
#'
#' @param proj_root_path root path of the project, generate with [DbCon] and
#' assess with DbCon$new()$proj_root_path.
#' @param overwrite overwriting the copied python codes or not. Default to FALSE
#'
#' @return a newly copied folder called "rpwf" under the provided project path.
#' @export
#'
#' @examples
#' tmp <- tempdir()
#' rpwf_cp_py_codes(tmp)
#' list.files(paste0(tmp, "/rpwf"), recursive = TRUE)
rpwf_cp_py_codes <- function(proj_root_path, overwrite = FALSE) {
  to_folder <- paste(proj_root_path, "rpwf", sep = "/")
  copy_fns <- function() {
    from_folder <-
      system.file("python", "rpwf", package = "rpwf", mustWork = TRUE)
    file.copy(from_folder, proj_root_path, recursive = TRUE)
  }

  if (!dir.exists(to_folder)) {
    message("creating folder 'rpwf' under provided root path")
    copy_fns()
  } else if (overwrite == TRUE) {
    message("folder 'rpwf' found, overwriting python codes in this folder")
    copy_fns()
  } else {
    message("folder 'rpwf' found, not copying codes over")
  }
}
